# x86-64 Assembly 

> "Nearing Machine Code Representation"

## Introduction/Motivation

Not so long ago (in a galaxy not so far away), programmers wrote most of their code in assembly. While programmers today primarily use higher level languages (Python, C, etc), it is not uncommon to debug the assembly of your code. These higher level languages afterall typically translate down to an assemble or assembly-like language. 

If you are interested in cybersecurity and reverse engineering, folks more frequently write and analyze assembly code. For high performance applications like [games](https://www.gamasutra.com/view/news/169946/CC_low_level_curriculum_Looking_at_optimized_assembly.php), programmers may write very optimized code using assembly to get things *just* right. If you are working in hardware or an embededd device, you might also do some assembly programming, as other languages environments are too bulky to support on a small device. Even web developers are using something called 'webassembly'. Hmm, the list is getting long here--I think the point is that learning assembly has quite some relevance! Let's dig in and get some practice.

In today's lab you are going to get some practice looking at assembly.

# Part 0 - Godbolt

I **strongly** recommend using the godbolt tool (https://godbolt.org/) to write and experiment with your C programs for this exercise.  The color mappings will help you see what is going on with the generated assembly. You **should** try using both godbolt and your compiler to generate assembly.

Here is an example of the Godbolt tool (and also shows part 4 of this lab)
<img src="./assembly.PNG">

# Part 1- Compiler Generated Assembly

Let us get some experience reading assembly code generated by the compiler (or godbolt)! It is actually kind of fun, you may learn some new instructions, and at the very least gain some intuition for what code the compiler is generating.

## Compiler generated assembly 1 - Swap

- Write a C program that swaps two integers(in the main body of code).
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as swap_int.s).
  - Use: `gcc -O0 -fno-builtin swap_int.c -S -o swap_int.s`
- Now modify your program to swap two long's.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as swap_long.s).
  - Use: `gcc -O0 -fno-builtin swap_long.c -S -o swap_long.s`
- Compare each of the two assembly files using diff. See what changed.
- diff syntax
  - Use: `diff -y swap_int.s swap_long.s`
  
### Response/Observations

- The suffix of mov – movl in swap_int, whereas movq in swap_long.
- Memory size according to the Assembly-code suffix: 4-byte for swap_int and 8-byte for swap_long.
- The assembly registers: %eax in swap_int; %rax in swap_long.
- swap_int – the mov instructed to have a l appended to it, which show an indication that a double word is being moved. Whereas for swap_long – the mov instructed to have a q appended to it, which show an indication that a quad word is being moved. Otherwise, the two assembly files look almost identical to each other.

## Compiler generated assembly 2 - Functions

- Write a C program that swaps two integers in a **function** (You may use today's slide as a reference)
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as swap.s).
  - Use: `gcc -O0 -fno-builtin  swap.c -S -o swap.s`
- Do the instructions use memory/registers in a different way?

### Response/Observations

- Once the swap function was creat, when compile for assembly the intrcution utilized registers to reserved for any special useage. Specifically, the swap method utilzed the usage %rdi and %rsi for the first and second parameter. Both registers are the pinters to any integers that we would want to swap. In this case, the integers are 1, and -2.
- In order to see any diffrences in the assembly, we now see the usage of the parentheses in each line.
  - E.g. movl	%eax, -4(%rbp), 	movl	-8(%rbp), %edx, etc..

## Compiler generated assembly 3 - Static Array
- Write a C program called array.c that has an array of 400 integers in the function of main.
  - Initialize some of the values to something (do not use a loop) (e.g. myArray[0]=72; myArray[70]=56; etc)
  	- Note that it is helpful to use 'weird' numbers so you can see where they jump out.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as array.s).
  - Use: `gcc -O0 -fno-builtin  array.c -S -o array.s`
- How much are the offsets from the address?

### Response/Observations

- To calculate the offset, its calculated the size of integers(the memory size of the assembly code suufix) muliply with the index. By doing this, the point of the array will get you the pointer to a specific integer that you assigned. The point of the array should be always point to the first element address. 
- 400 integers, which mean that it requires 1600 bits of memory spcace: 400 integer * 4-bytes.
- The movl instructions, you can see that 72 is moved by -1600, whereas 56 is moved by -1320. By calculated the diffrences between the starting offset and the addresses of the integers at position i, you will see that it is offset by 4 x i.

## Compiler generated assembly 4 - Dynamic Array 

- Write a C program called array2.c that has an array of 400 integers in the function of main that is dynamically allocated.
  - Initialize some of the values to something (do not use a loop) (e.g. myArray[66]=712; myArray[70]=536; etc)
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as array2.s).
  - Use: `gcc -O0 -fno-builtin  array2.c -S -o array2.s`
- Study the assembly and think about what is different from the static array.

### Response/Observations

- With the allocating memory of the heap being implemented, the dynamic array very different in comparison to static array in assembly.
- Unlike static array, the integer in dynamic arrays are temporary assigned and then store in th heap. As for static array, the integers are being directly assiged to the a register and then stored the integer locally.
- Note: in the array2.s there is an addq and subq. The two registers are there to update any pointer depedning on the integer position at which it being added. From there, you able to diffrences the pointer by adding it to the revelant integer. Lastly, when moving back to the initial position, we can continue to add the integers. 

## Compiler generated assembly 5 - Goto
The C programming language has a 'goto' command, search how to use it if you have not previously.

- Write a C program using the goto command and a label.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as goto.s).
  - Use: `gcc -O0 -fno-builtin  goto.c -S -o goto.s`
- Observe what kind of jmp statement is inserted.

### Response/Observations

- jmp .L2 – Unconditional statement
- je .L3 – the statement would jump if it equal to 0

## Compiler generated assembly 6 - For-loops
- Write a C program using a for-loop that counts to 5.
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as for.s).
  - Use: `gcc -O0 -fno-builtin  for.c -S -o for.s`
- Observe where the code goes for the condition statement (at the start or at the end?).

### Response/Observations

- Thought it is at the end of the code, but the execution happens at the beginning. 
- If you're observe the codes in for.c and for.s, you able to see that after initialized i there's an instruction to jump to .L2. If the condition is met, then the jump would go to the for loop. Otherwise, it exit and the body isn't executed.

## Compiler generated assembly 7 - Switch Statements

- Write a C program using a switch statement (Sample here)[https://www.tutorialspoint.com/cprogramming/switch_statement_in_c.htm].
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as switch.s).
  - Use: `gcc -O0 -fno-builtin switch.c -S -o switch.s`
- See what code a switch statement generates. Is it optimal?

### Response/Observations

- A switch statment is generate based on the cases conditional codes and branches. 
- Is it optimal because once the case conditional is met, then it would break. This mean that you only need to go into branches if the condition is met the requirment. 

## Compiler generated assembly 8 - Add Function

- Write a C program that calls an add function(long add(long a, long b).
  - Save, Compile, and Run the program to verify it works.
- Output the assembly from that program (Save it as add.s).
  - Use: `gcc -O0 -fno-builtin add.c -S -o add.s`
- Observe the outputs
- Observe arguments put into registers
- Observe where 'popq' is called.

### Response/Observations

- popq executed at the end of the function.
- The argument(s) put into the register assembly suffix are the memory addresses for long function.

# More resources to help

- Matt Godbolt has written a great tool to help understand assembly generated from the compiler. 
  - https://godbolt.org/
- An assembly cheat sheet from Brown
  - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
- MIT Cheat sheet
  - http://6.035.scripts.mit.edu/sp17/x86-64-architecture-guide.html

# Deliverable

- For part 1, add your .S files that you have generated to this repository.
  - Note this submission will be auto graded for completion (i.e. save the file names as shown).
  - Add your observations in the appropriate response/observations section for each code.

# Going Further

- (Optional) Try the objdump example to read the disassembly from your programs executables. Observe how close the output is to the compiler generated output.
